" (the following line is a modeline)
" vim: foldmethod=marker

" Custom folding for my custom HTML slides. Generated by ChatGPT and adapted
" slightly. Unfortunately, this cannot be used in a modeline (see bottom of
" file).

lua << EOF
local M = {}

-- Cache per-buffer, refresh when b:changedtick changes
local function ensure_index(bufnr)
  bufnr = bufnr or 0
  local tick = vim.b[bufnr].changedtick
  local cache = vim.b[bufnr].my_htmlslides_cache
  if cache and cache.tick == tick and cache.ranges then
    return cache
  end

  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
  local n = #lines

  local function chunk_from(i, k)
    local j, out = i, {}
    while j <= n and j < i + k do
      out[#out+1] = lines[j]
      if lines[j]:find(">", 1, true) then break end
      j = j + 1
    end
    return table.concat(out, "\n")
  end

  -- locate <body ...>
  local body_s = nil
  for i = 1, n do
    local l = lines[i]
    if l and l:lower():find("<body") then
      body_s = i
      break
    end
  end

  -- locate <head ...> ... </head>, and include blanks up to before <body>
  local head_s, head_close = nil, nil
  for i = 1, n do
    local l = lines[i]
    if l and l:lower():find("<head") then
      head_s = i
      for j = i, n do
        local lj = lines[j]
        if lj and lj:lower():find("</head>") then
          head_close = j
          break
        end
      end
      break
    end
  end

  local function extract_head_title(s, e)
    local max_scan = math.min(e, s + 120)
    for k = s, max_scan do
      local l = lines[k]
      if l and l:lower():find("<title") then
        local chunk = l
        local j = k + 1
        while j <= math.min(e, k + 20) do
          local lc = chunk:lower()
          if lc:find("</title>") then break end
          chunk = chunk .. "\n" .. (lines[j] or "")
          j = j + 1
        end
        local inner = chunk:gsub("^.-<title[^>]*>", "")
        inner = inner:gsub("</title>.-$", "")
        inner = inner:gsub("<[^>]->", "")
        inner = inner:gsub("^%s+", ""):gsub("%s+$", "")
        return (inner ~= "" and inner) or "head"
      end
    end
    return "head"
  end

  -- find slide starts: <div ... class="...slide..." ...>
  local starts = {}
  for i = 1, n do
    local l = lines[i]
    if l and l:find("<div", 1, true) then
      local chunk = (chunk_from(i, 6)):lower()
      if chunk:find("<div", 1, true)
         and chunk:find('class%s*=%s*"', 1)
         and chunk:find('class%s*=%s*"%s*[^"]-slide[^"]-"') then
        starts[#starts+1] = i
      end
    end
  end

  local function extract_slide_title(s, e)
    local max_scan = math.min(e, s + 60)
    for k = s, max_scan do
      local l = lines[k]
      if l and l:find("<h[123]") then
        local chunk = l
        local j = k + 1
        while j <= math.min(e, k + 12) do
          local lc = chunk:lower()
          if lc:find("</h1>") or lc:find("</h2>") or lc:find("</h3>") then
            break
          end
          chunk = chunk .. "\n" .. (lines[j] or "")
          j = j + 1
        end
        local inner = chunk:gsub("^.-<h[123][^>]*>", "")
        inner = inner:gsub("</h[123]>.-$", "")
        inner = inner:gsub("<[^>]->", "")
        inner = inner:gsub("^%s+", ""):gsub("%s+$", "")
        if inner ~= "" then return inner end
      end
    end
    return "Slide"
  end

  -- Build ranges: head (if present) + slides
  local ranges = {}

  if head_s then
    local e
    if body_s then
      e = body_s - 1                     -- include blanks before <body>
    else
      e = head_close or n                -- fallback if no <body> found
    end
    if e < head_s then e = head_close or head_s end
    ranges[#ranges+1] = {
      s = head_s, e = e,
      title = extract_head_title(head_s, e),
      kind = "head"
    }
  end

  for idx, s in ipairs(starts) do
    local e = (starts[idx + 1] or (n + 1)) - 1
    ranges[#ranges+1] = {
      s = s, e = e,
      title = extract_slide_title(s, e),
      kind = "slide"
    }
  end

  table.sort(ranges, function(a, b) return a.s < b.s end)

  local function find_range_for_line(lnum)
    local lo, hi = 1, #ranges
    while lo <= hi do
      local mid = math.floor((lo + hi) / 2)
      local r = ranges[mid]
      if lnum < r.s then
        hi = mid - 1
      elseif lnum > r.e then
        lo = mid + 1
      else
        return r
      end
    end
    return nil
  end

  cache = { tick = tick, ranges = ranges, find = find_range_for_line }
  vim.b[bufnr].my_htmlslides_cache = cache
  return cache
end

function M.foldexpr()
  local lnum = vim.v.lnum or 1
  local cache = ensure_index(0)
  local r = cache.find(lnum)
  if r then
    if lnum == r.s then
      return ">1"                         -- start new fold at head/slide open
    end
    return 1                              -- inside fold (includes separators)
  end
  return 0                                -- outside (doctype/html/body tags)
end

function M.foldtext()
  local s = vim.v.foldstart or 1
  local e = vim.v.foldend or s
  local cache = ensure_index(0)
  local r = cache.find(s) or cache.find(s + 1)
  local title = (r and r.title) or "Block"
  if r and r.kind == "head" then
    title = "HEAD: " .. title
  end
  return string.format("â–¶ %s  [%d lines]", title, (e - s + 1))
end

_G.my_htmlslides = M
EOF

" Lua in modelines doesn't run due to sandboxing (not even with `set
" modelineexpr`). Setup can be done instead by calling this function.
function MyCustomHtmlSlidesFoldSetup()
  setlocal foldmethod=expr
  setlocal foldexpr=luaeval('my_htmlslides.foldexpr()')
  setlocal foldtext=luaeval('my_htmlslides.foldtext()')
endfunction

